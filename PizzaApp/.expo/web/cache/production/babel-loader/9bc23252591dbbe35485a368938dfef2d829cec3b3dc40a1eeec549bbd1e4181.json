{"ast":null,"code":"import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import{useState,useEffect,useRef}from\"react\";import BackHandler from\"react-native-web/dist/exports/BackHandler\";import Platform from\"react-native-web/dist/exports/Platform\";import{createNavigationContainerRef}from\"@react-navigation/native\";import Config from\"../config\";import{useIsMounted}from\"../utils/useIsMounted\";export var navigationRef=createNavigationContainerRef();export function getActiveRouteName(state){var route=state.routes[state.index];if(!route.state)return route.name;return getActiveRouteName(route.state);}export function useBackButtonHandler(canExit){if(Platform.OS===\"ios\")return;var canExitRef=useRef(canExit);useEffect(function(){canExitRef.current=canExit;},[canExit]);useEffect(function(){var onBackPress=function onBackPress(){if(!navigationRef.isReady()){return false;}var routeName=getActiveRouteName(navigationRef.getRootState());if(canExitRef.current(routeName)){BackHandler.exitApp();return true;}if(navigationRef.canGoBack()){navigationRef.goBack();return true;}return false;};BackHandler.addEventListener(\"hardwareBackPress\",onBackPress);return function(){return BackHandler.removeEventListener(\"hardwareBackPress\",onBackPress);};},[]);}function navigationRestoredDefaultState(persistNavigation){if(persistNavigation===\"always\")return false;if(persistNavigation===\"dev\"&&__DEV__)return false;if(persistNavigation===\"prod\"&&!__DEV__)return false;return true;}export function useNavigationPersistence(storage,persistenceKey){var _useState=useState(),_useState2=_slicedToArray(_useState,2),initialNavigationState=_useState2[0],setInitialNavigationState=_useState2[1];var isMounted=useIsMounted();var initNavState=navigationRestoredDefaultState(Config.persistNavigation);var _useState3=useState(initNavState),_useState4=_slicedToArray(_useState3,2),isRestored=_useState4[0],setIsRestored=_useState4[1];var routeNameRef=useRef();var onNavigationStateChange=function onNavigationStateChange(state){var previousRouteName=routeNameRef.current;var currentRouteName=getActiveRouteName(state);if(previousRouteName!==currentRouteName){if(__DEV__){console.tron.log(currentRouteName);}}routeNameRef.current=currentRouteName;storage.save(persistenceKey,state);};var restoreState=function(){var _ref=_asyncToGenerator(function*(){try{var state=yield storage.load(persistenceKey);if(state)setInitialNavigationState(state);}finally{if(isMounted())setIsRestored(true);}});return function restoreState(){return _ref.apply(this,arguments);};}();useEffect(function(){if(!isRestored)restoreState();},[isRestored]);return{onNavigationStateChange:onNavigationStateChange,restoreState:restoreState,isRestored:isRestored,initialNavigationState:initialNavigationState};}export function navigate(){if(navigationRef.isReady()){navigationRef.navigate.apply(navigationRef,arguments);}}export function goBack(){if(navigationRef.isReady()&&navigationRef.canGoBack()){navigationRef.goBack();}}export function resetRoot(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{index:0,routes:[]};if(navigationRef.isReady()){navigationRef.resetRoot(state);}}","map":{"version":3,"names":["useState","useEffect","useRef","BackHandler","Platform","createNavigationContainerRef","Config","useIsMounted","navigationRef","getActiveRouteName","state","route","routes","index","name","useBackButtonHandler","canExit","OS","canExitRef","current","onBackPress","isReady","routeName","getRootState","exitApp","canGoBack","goBack","addEventListener","removeEventListener","navigationRestoredDefaultState","persistNavigation","__DEV__","useNavigationPersistence","storage","persistenceKey","_useState","_useState2","_slicedToArray","initialNavigationState","setInitialNavigationState","isMounted","initNavState","_useState3","_useState4","isRestored","setIsRestored","routeNameRef","onNavigationStateChange","previousRouteName","currentRouteName","console","tron","log","save","restoreState","_ref","_asyncToGenerator","load","apply","arguments","navigate","resetRoot","length","undefined"],"sources":["/home/ehsan/dockerize-expo-rn-web-app/PizzaApp/app/navigators/navigationUtilities.ts"],"sourcesContent":["import { useState, useEffect, useRef } from \"react\"\nimport { BackHandler, Platform } from \"react-native\"\nimport { NavigationState, createNavigationContainerRef } from \"@react-navigation/native\"\nimport Config from \"../config\"\nimport type { PersistNavigationConfig } from \"../config/config.base\"\nimport { useIsMounted } from \"../utils/useIsMounted\"\nimport type { AppStackParamList, NavigationProps } from \"./AppNavigator\"\n\nimport * as storage from \"../utils/storage\"\n\ntype Storage = typeof storage\n\n/**\n * Reference to the root App Navigator.\n *\n * If needed, you can use this to access the navigation object outside of a\n * `NavigationContainer` context. However, it's recommended to use the `useNavigation` hook whenever possible.\n * @see https://reactnavigation.org/docs/navigating-without-navigation-prop/\n *\n * The types on this reference will only let you reference top level navigators. If you have\n * nested navigators, you'll need to use the `useNavigation` with the stack navigator's ParamList type.\n */\nexport const navigationRef = createNavigationContainerRef<AppStackParamList>()\n\n/**\n * Gets the current screen from any navigation state.\n */\nexport function getActiveRouteName(\n  state: ReturnType<typeof navigationRef.getRootState>,\n): keyof AppStackParamList {\n  const route = state.routes[state.index]\n\n  // Found the active route -- return the name\n  if (!route.state) return route.name as keyof AppStackParamList\n\n  // Recursive call to deal with nested routers\n  return getActiveRouteName(route.state as NavigationState<AppStackParamList>)\n}\n\n/**\n * Hook that handles Android back button presses and forwards those on to\n * the navigation or allows exiting the app.\n */\nexport function useBackButtonHandler(canExit: (routeName: string) => boolean) {\n  // ignore if iOS ... no back button!\n  if (Platform.OS === \"ios\") return\n\n  // The reason we're using a ref here is because we need to be able\n  // to update the canExit function without re-setting up all the listeners\n  const canExitRef = useRef(canExit)\n\n  useEffect(() => {\n    canExitRef.current = canExit\n  }, [canExit])\n\n  useEffect(() => {\n    // We'll fire this when the back button is pressed on Android.\n    const onBackPress = () => {\n      if (!navigationRef.isReady()) {\n        return false\n      }\n\n      // grab the current route\n      const routeName = getActiveRouteName(navigationRef.getRootState())\n\n      // are we allowed to exit?\n      if (canExitRef.current(routeName)) {\n        // exit and let the system know we've handled the event\n        BackHandler.exitApp()\n        return true\n      }\n\n      // we can't exit, so let's turn this into a back action\n      if (navigationRef.canGoBack()) {\n        navigationRef.goBack()\n        return true\n      }\n\n      return false\n    }\n\n    // Subscribe when we come to life\n    BackHandler.addEventListener(\"hardwareBackPress\", onBackPress)\n\n    // Unsubscribe when we're done\n    return () => BackHandler.removeEventListener(\"hardwareBackPress\", onBackPress)\n  }, [])\n}\n\n/**\n * This helper function will determine whether we should enable navigation persistence\n * based on a config setting and the __DEV__ environment (dev or prod).\n */\nfunction navigationRestoredDefaultState(persistNavigation: PersistNavigationConfig) {\n  if (persistNavigation === \"always\") return false\n  if (persistNavigation === \"dev\" && __DEV__) return false\n  if (persistNavigation === \"prod\" && !__DEV__) return false\n\n  // all other cases, disable restoration by returning true\n  return true\n}\n\n/**\n * Custom hook for persisting navigation state.\n */\nexport function useNavigationPersistence(storage: Storage, persistenceKey: string) {\n  const [initialNavigationState, setInitialNavigationState] =\n    useState<NavigationProps[\"initialState\"]>()\n  const isMounted = useIsMounted()\n\n  const initNavState = navigationRestoredDefaultState(Config.persistNavigation)\n  const [isRestored, setIsRestored] = useState(initNavState)\n\n  const routeNameRef = useRef<keyof AppStackParamList | undefined>()\n\n  const onNavigationStateChange: NavigationProps[\"onStateChange\"] = (state) => {\n    const previousRouteName = routeNameRef.current\n    const currentRouteName = getActiveRouteName(state)\n\n    if (previousRouteName !== currentRouteName) {\n      // track screens.\n      if (__DEV__) {\n        console.tron.log(currentRouteName)\n      }\n    }\n\n    // Save the current route name for later comparison\n    routeNameRef.current = currentRouteName\n\n    // Persist state to storage\n    storage.save(persistenceKey, state)\n  }\n\n  const restoreState = async () => {\n    try {\n      const state = (await storage.load(persistenceKey)) as NavigationProps[\"initialState\"] | null\n      if (state) setInitialNavigationState(state)\n    } finally {\n      if (isMounted()) setIsRestored(true)\n    }\n  }\n\n  useEffect(() => {\n    if (!isRestored) restoreState()\n  }, [isRestored])\n\n  return { onNavigationStateChange, restoreState, isRestored, initialNavigationState }\n}\n\n/**\n * use this to navigate without the navigation\n * prop. If you have access to the navigation prop, do not use this.\n * @see https://reactnavigation.org/docs/navigating-without-navigation-prop/\n */\nexport function navigate(...args: Parameters<typeof navigationRef.navigate>) {\n  if (navigationRef.isReady()) {\n    navigationRef.navigate(...args)\n  }\n}\n\n/**\n * This function is used to go back in a navigation stack, if it's possible to go back.\n * If the navigation stack can't go back, nothing happens.\n * The navigationRef variable is a React ref that references a navigation object.\n * The navigationRef variable is set in the App component.\n */\nexport function goBack() {\n  if (navigationRef.isReady() && navigationRef.canGoBack()) {\n    navigationRef.goBack()\n  }\n}\n\n/**\n * resetRoot will reset the root navigation state to the given params.\n */\nexport function resetRoot(\n  state: Parameters<typeof navigationRef.resetRoot>[0] = { index: 0, routes: [] },\n) {\n  if (navigationRef.isReady()) {\n    navigationRef.resetRoot(state)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}